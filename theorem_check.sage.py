

# This file was *autogenerated* from the file theorem_check.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_12539 = Integer(12539); _sage_const_33 = Integer(33); _sage_const_145 = Integer(145); _sage_const_31 = Integer(31); _sage_const_141 = Integer(141); _sage_const_0p005 = RealNumber('0.005'); _sage_const_0p013 = RealNumber('0.013'); _sage_const_0p029 = RealNumber('0.029'); _sage_const_0p054 = RealNumber('0.054'); _sage_const_0p086 = RealNumber('0.086'); _sage_const_0p118 = RealNumber('0.118'); _sage_const_0p141 = RealNumber('0.141'); _sage_const_0p146 = RealNumber('0.146'); _sage_const_0p132 = RealNumber('0.132'); _sage_const_0p105 = RealNumber('0.105'); _sage_const_0p074 = RealNumber('0.074'); _sage_const_0p046 = RealNumber('0.046'); _sage_const_0p025 = RealNumber('0.025'); _sage_const_0p012 = RealNumber('0.012'); _sage_const_0p001 = RealNumber('0.001'); _sage_const_0p002 = RealNumber('0.002'); _sage_const_0p0123 = RealNumber('0.0123'); _sage_const_0p0464 = RealNumber('0.0464'); _sage_const_0p0746 = RealNumber('0.0746'); _sage_const_0p145 = RealNumber('0.145'); _sage_const_0p140 = RealNumber('0.140'); _sage_const_1p = RealNumber('1.')
reset()
from random import sample
import numpy as np
import matplotlib.pyplot as plt

def vectorSum(c,k):
	res = [_sage_const_0 ] * len(c)
	for i in range(len(c)):
		res[i] = c[i] + k
	return res


def sparse_mul(a, b, n):
	c = [_sage_const_0 ] * n
	for i in a:
		new_pos = [_sage_const_0 ] * (len(b))
		for j in range(len(b)):
			new_pos[j] = (b[j] + i) % n
			c[new_pos[j]] = (c[new_pos[j]] + _sage_const_1 ) % _sage_const_2 
	return c

k = _sage_const_12539 
n = _sage_const_2  * k
w_u = _sage_const_33 
w_f = _sage_const_145 
w_c = _sage_const_31 
w_e = _sage_const_141 

# Ogni entrata z-esima di x codifica P((d_i(x)_j=z) | (e_i)_j = 0)
xx = [_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0p005 ,_sage_const_0p013 ,_sage_const_0p029 ,_sage_const_0p054 ,_sage_const_0p086 ,_sage_const_0p118 ,_sage_const_0p141 ,_sage_const_0p146 ,_sage_const_0p132 ,_sage_const_0p105 ,_sage_const_0p074 ,_sage_const_0p046 ,_sage_const_0p025 ,_sage_const_0p012 ,_sage_const_0p005 ,_sage_const_0p001 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ]
# Ogni entrata z-esima di y codifica P((d_i(x)_j=z) | (e_i)_j = 1)
yy = [_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0p002 ,_sage_const_0p005 ,_sage_const_0p0123 ,_sage_const_0p025 ,_sage_const_0p0464 ,_sage_const_0p0746 ,_sage_const_0p105 ,_sage_const_0p132 ,_sage_const_0p145 ,_sage_const_0p140 ,_sage_const_0p118 ,_sage_const_0p086 ,_sage_const_0p054 ,_sage_const_0p029 ,_sage_const_0p013 ,_sage_const_0p005 ,_sage_const_0p001 ]

xxx = [(idx, x) for idx, x in enumerate(xx)]
yyy = [(idy, y) for idy, y in enumerate(yy)]

#Stampo 
p1 = list_plot(list(xxx),color='red')
p2 = list_plot(list(yyy),color='blue')

p = p1+p2
p.show()

#Stimo le probabilità in modo sperimentale
# calcolo d_i(x)
u = sample(range(k), w_u)  # sample u poly
f = sample(range(k), w_f)  # sample f poly
c = sample(range(k), w_c)  # sample c polynomial
e = sample(range(k), w_e)  # sample e polynomial

##compute s = u f + c e
uf = sparse_mul(u, f, k)
ce = sparse_mul(c, e, k)
s = np.mod([i+j for i,j in zip(uf,ce)],_sage_const_2 )

# creo i vettori che tengono conto del numero di occorrenze z per cui d_i(x)_j=z, distinguendo e_ij = 0 ed e_ij=1
pos_0 = []
corr_values_0 = []
pos_1 = []
corr_values_1 = []

for i in range(k):
	shifted_c_support = np.mod(vectorSum(c,i),k); # shift of c by 0,1,2,3,...
	corr_val = _sage_const_0 
	for j in range(len(shifted_c_support)):
		corr_val = corr_val + s[shifted_c_support[j]]
	if (i not in e): #if e_i == 0
		pos_0.append(i) # take note of i s.t. e_i==0
		corr_values_0.append(corr_val) # take note of corr_values
	else:
		pos_1.append(i)
		corr_values_1.append(corr_val)
	
	# calcolo la probabilità di aver osservato questo fenomeno
number_of_tries_1 = w_e
number_of_tries_0 = k-w_e
d_values_for_0 = zero_vector(w_c+_sage_const_1 )
d_values_for_1 = zero_vector(w_c+_sage_const_1 )
prob_0 = []
prob_1 = []

for i in range(k-w_e):
	d_values_for_0[corr_values_0[i]] += _sage_const_1 
for i in range(len(d_values_for_0)):
	prob_0.append(d_values_for_0[i] / number_of_tries_0 * _sage_const_1p )

for i in range(w_e):
	d_values_for_1[corr_values_1[i]] += _sage_const_1 
for i in range(len(d_values_for_1)):
	prob_1.append(d_values_for_1[i] / number_of_tries_1 * _sage_const_1p )

#Stampo tutto su file
fileName00 = "theory_0.dat"
with open(fileName00, "w") as f:
	f.write("x y\n")
	for i in range(len(xx)):
		f.write(str(i) + " " + str(xx[i]) + "\n")
f.close()

fileName01 = "exp_0.dat"
with open(fileName01, "w") as f:
	f.write("x y\n")
	for i in range(len(prob_0)):
		f.write(str(i) + " " + str(prob_0[i]) + "\n")
f.close()

fileName10 = "theory_1.dat"
with open(fileName10, "w") as f:
	f.write("x y\n")
	for i in range(len(yy)):
		f.write(str(i) + " " + str(yy[i]) + "\n")
f.close()

fileName11 = "exp_1.dat"
with open(fileName11, "w") as f:
	f.write("x y\n")
	for i in range(len(prob_1)):
		f.write(str(i) + " " + str(prob_1[i]) + "\n")
f.close()

